// Updated game logic per request:
// - removed "normal" mode
// - fixed difficulty button selection
// - soda can gives 1.5x speed temporary
// - rare meteor shower event (easy & hard) that spawns meteors; touching meteor surface explodes
// - very rare clock item adds 5-10s when picked
// - coin is common pickup (ðŸª™), diamond (ðŸ’Ž) is rare and worth more
// - running man replaced with dollar sign (ðŸ’²)
// - click performs short dash (no teleport); ensured overlay/panels clickable

// Canvas internal resolution
const INTERNAL_W = 1280;
const INTERNAL_H = 720;

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let canvasScale = 1;

function resizeCanvas(){
  const parent = canvas.parentElement;
  const rect = parent.getBoundingClientRect();
  canvas.width = INTERNAL_W;
  canvas.height = INTERNAL_H;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  canvasScale = canvas.width / INTERNAL_W;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* UI */
const ui = {
  score: document.getElementById('score'),
  coins: document.getElementById('coins'),
  gems: document.getElementById('gems'),
  hp: document.getElementById('hp'),
  time: document.getElementById('time'),
  overlay: document.getElementById('overlay'),
  menu: document.getElementById('menu'),
  pause: document.getElementById('pause'),
  gameover: document.getElementById('gameover'),
  msg: document.getElementById('msg'),
  finalStats: document.getElementById('final-stats'),
  playBtn: document.getElementById('play'),
  easyBtn: document.getElementById('easy'),
  hardBtn: document.getElementById('hard'),
  restartBtn: document.getElementById('restart'),
  resumeBtn: document.getElementById('resume'),
  menuHomeBtn: document.getElementById('menu-home'),
  menuBackBtn: document.getElementById('menu-back')
};

/* State */
let keys = {};
let lastTime = 0;
let spawnTimer = 0;
let dragonTimer = 0;
let burgerTimer = 0;
let meteorTimer = 0;
let clockTimer = 0;
let gameTime = 60;
let score = 0, coins = 0, gems = 0;
let hp = 3.0;
let running = false;
let paused = false;
let difficulty = 'normal'; // initial default (will be changed by menu)
let state = 'menu'; // menu, playing, paused, gameover

/* Entities */
let player, hazards = [], pickups = [];

/* Effects */
let shakeTime = 0, shakeIntensity = 0;
let invulTime = 0, invulFlashTimer = 0;
let particles = [];
let fires = [];
let burger = null;
let clockItem = null;
let dragon = null;
let meteors = []; // for meteor shower

/* Death */
let dying = false;
let deathVy = 0;
const GRAVITY = 900;
const DEATH_JUMP = -420;

/* Soda buff */
let sodaBuff = 0; // seconds remaining for 1.5x speed

/* Dash */
let lastDash = -9999;
const DASH_COOLDOWN = 0.45;
const DASH_DISTANCE = 110;

function rnd(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function setHP(v){
  hp = Math.max(0, Math.min(3, +v.toFixed(2)));
  ui.hp.textContent = hp.toFixed(1);
}
function setCoins(n){ coins = Math.max(0, Math.floor(n)); ui.coins.textContent = coins; }
function setGems(n){ gems = Math.max(0, Math.floor(n)); ui.gems.textContent = gems; }
function setScore(n){ score = Math.max(0, Math.floor(n)); ui.score.textContent = score; }

/* UI state */
function markDifficultyButton(){
  [ui.easyBtn, ui.hardBtn].forEach(b=> b.classList.remove('active'));
  if(difficulty === 'easy') ui.easyBtn.classList.add('active');
  else if(difficulty === 'hard') ui.hardBtn.classList.add('active');
}

/* Menus */
function showMenu(){
  state = 'menu';
  running = false;
  paused = false;
  ui.menu.classList.remove('hidden');
  ui.pause.classList.add('hidden');
  ui.gameover.classList.add('hidden');
  ui.overlay.classList.add('overlay-active');
}
function startGame(){
  state = 'playing';
  running = true;
  paused = false;
  ui.menu.classList.add('hidden');
  ui.pause.classList.add('hidden');
  ui.gameover.classList.add('hidden');
  ui.overlay.classList.remove('overlay-active');
  initGame();
  lastTime = performance.now();
  requestAnimationFrame(loop);
}
function showPause(){
  if(state !== 'playing') return;
  state = 'paused';
  paused = true;
  ui.pause.classList.remove('hidden');
  ui.overlay.classList.add('overlay-active');
}
function resumeGame(){
  if(state !== 'paused') return;
  state = 'playing';
  paused = false;
  ui.pause.classList.add('hidden');
  ui.overlay.classList.remove('overlay-active');
  lastTime = performance.now();
  requestAnimationFrame(loop);
}
function showGameOver(text){
  state = 'gameover';
  running = false;
  paused = false;
  dying = false;
  ui.menu.classList.add('hidden');
  ui.pause.classList.add('hidden');
  ui.gameover.classList.remove('hidden');
  ui.msg.textContent = text;
  ui.finalStats.textContent = `Score ${score} â€¢ Coins ${coins} â€¢ Gems ${gems}`;
  ui.overlay.classList.add('overlay-active');
}

/* Init game */
function initGame(){
  setScore(0); setCoins(0); setGems(0); setHP(3.0);
  gameTime = (difficulty === 'easy') ? 90 : (difficulty === 'hard') ? 45 : 60;
  hazards = []; pickups = [];
  player = {
    x: INTERNAL_W/2,
    y: INTERNAL_H/2,
    w: 28,
    h: 28,
    baseSpeed: (difficulty==='hard'?200:160),
    speed: (difficulty==='hard'?200:160),
    emoji: 'ðŸ™‚',
    vx: 0, vy: 0
  };
  lastTime = performance.now();
  spawnPickup();
  spawnHazard();
  spawnTimer = 0; dragonTimer = 0; burgerTimer = 0; meteorTimer = 0; clockTimer = 0;
  dragon = null; fires = []; burger = null; clockItem = null; meteors = []; particles = [];
  shakeTime = 0; shakeIntensity = 0;
  invulTime = 0; invulFlashTimer = 0;
  dying = false; deathVy = 0; sodaBuff = 0;
  lastDash = -9999;
}

/* Pickups / hazards */
function spawnPickup(){
  // spawn common coins and rare diamonds randomly initial set
  for(let i=0;i<6;i++){
    pickups.push({ type:'coin', x: rnd(60,INTERNAL_W-60), y: rnd(60,INTERNAL_H-60), r:12, emoji:'ðŸª™', value:1 });
  }
  // one rare diamond sometimes
  if(Math.random() < 0.18) pickups.push({ type:'gem', x: rnd(80,INTERNAL_W-80), y: rnd(80,INTERNAL_H-80), r:14, emoji:'ðŸ’Ž', value:5 });
}
function spawnHazard(){
  const count = (difficulty==='easy')?2:3;
  for(let i=0;i<count;i++){
    const speed = (difficulty==='hard')? rnd(-140,140) : rnd(-80,80);
    hazards.push({ x:rnd(60,INTERNAL_W-60), y:rnd(60,INTERNAL_H-60), vx: speed, vy: rnd(-80,80), r:16, emoji:'ðŸ§¨' });
  }
}

/* Meteor shower event (easy & hard) */
function tryStartMeteorShower(dt){
  if(!(difficulty === 'easy' || difficulty === 'hard')) return;
  meteorTimer += dt;
  // Occasional chance; rarer on easy, more likely on hard, only if none active
  if(meteorTimer > 12 + Math.random()*18 && meteors.length === 0){
    meteorTimer = 0;
    const chance = (difficulty==='hard') ? 0.72 : 0.32;
    if(Math.random() < chance){
      // spawn burst of meteors from top at random x positions
      const count = 6 + Math.floor(Math.random()*10);
      for(let i=0;i<count;i++){
        meteors.push({
          x: rnd(40,INTERNAL_W-40),
          y: -rnd(60, 240) - i*20,
          vy: 220 + Math.random()*160,
          vx: rnd(-40,40),
          r: 14 + Math.random()*10,
          landed: false,
          life: 6
        });
      }
      // slight screen cue
      shakeTime = Math.max(shakeTime, 0.3);
      shakeIntensity = Math.max(shakeIntensity, 8);
    }
  }
}
function updateMeteors(dt){
  for(let i=meteors.length-1;i>=0;i--){
    const m = meteors[i];
    if(m.landed){
      m.life -= dt;
      if(m.life <= 0) meteors.splice(i,1);
      continue;
    }
    m.x += m.vx * dt;
    m.y += m.vy * dt;
    if(m.y >= INTERNAL_H - 40){ // hit surface
      m.y = INTERNAL_H - 40;
      m.landed = true;
      // explosion effect: spawn explosion particles and a temporary hazard
      spawnParticlesAt(m.x, m.y);
      hazards.push({ x:m.x, y:m.y, vx:0, vy:0, r:22, emoji:'ðŸ§¨' });
      // small screen shake
      shakeTime = Math.max(shakeTime, 0.35);
      shakeIntensity = Math.max(shakeIntensity, 10);
    }
  }
}

/* Dragon behavior (burst spit then flee) - only spawn in hard earlier, keep as before */
function trySpawnDragon(dt){
  if(difficulty !== 'hard') return;
  dragonTimer += dt;
  if(dragonTimer > 5 + Math.random()*4){
    dragonTimer = 0;
    if(!dragon && Math.random() < 0.65){
      const dropX = rnd(120, INTERNAL_W-120);
      const startX = Math.random() < 0.5 ? -160 : INTERNAL_W + 160;
      dragon = {
        x: startX,
        y: -180,
        targetX: dropX,
        surfaceY: rnd(100, 220),
        state: 'approaching',
        speed: 160 + Math.random()*80,
        spitBurstTotal: 8 + Math.floor(Math.random()*10),
        spitBurstInterval: 0.05 + Math.random()*0.06,
        spitBurstCount: 0,
        spitBurstTimer: 0.05,
        leaveDelay: 0.22
      };
    }
  }
}
function updateDragon(dt){
  if(!dragon) return;
  if(dragon.state === 'approaching'){
    const dx = dragon.targetX - dragon.x;
    const step = Math.sign(dx) * Math.min(Math.abs(dx), dragon.speed * dt);
    dragon.x += step;
    dragon.y += 60 * dt;
    if(Math.abs(dx) < 8 && dragon.y >= -10) dragon.state = 'dropping';
  } else if(dragon.state === 'dropping'){
    dragon.y += 300 * dt;
    if(dragon.y >= dragon.surfaceY){
      dragon.y = dragon.surfaceY;
      dragon.state = 'spitting';
      dragon.spitBurstCount = 0;
      dragon.spitBurstTimer = 0.05;
    }
  } else if(dragon.state === 'spitting'){
    dragon.spitBurstTimer -= dt;
    while(dragon.spitBurstTimer <= 0 && dragon.spitBurstCount < dragon.spitBurstTotal){
      spitBurstSmallFire();
      dragon.spitBurstCount++;
      dragon.spitBurstTimer += dragon.spitBurstInterval;
    }
    if(dragon.spitBurstCount >= dragon.spitBurstTotal){
      dragon.leaveDelay -= dt;
      if(dragon.leaveDelay <= 0){
        dragon.state = 'leaving';
        dragon.vx = (Math.random() < 0.5 ? -1 : 1) * (dragon.speed + 120);
        dragon.vy = -300;
      }
    }
  } else if(dragon.state === 'leaving'){
    dragon.x += dragon.vx * dt;
    dragon.y += dragon.vy * dt;
    dragon.vy += -420 * dt;
    if(dragon.y < -220 || dragon.x < -300 || dragon.x > INTERNAL_W + 300) dragon = null;
  }
}
function spitBurstSmallFire(){
  if(!dragon) return;
  const fx = dragon.x;
  const fy = dragon.y + 28;
  const aimX = player.x + rnd(-70,70);
  const aimY = player.y + rnd(-30,30);
  const dirX = aimX - fx;
  const dirY = aimY - fy;
  const len = Math.hypot(dirX, dirY) || 1;
  const speed = 420 + Math.random()*160;
  fires.push({
    x: fx, y: fy,
    vx: (dirX/len) * speed + rnd(-40,40),
    vy: (dirY/len) * speed + rnd(-30,30),
    r: 14, life: 2.5, emoji: 'ðŸ”¥'
  });
}

/* Fires update & collision */
function updateFires(dt){
  for(let i=fires.length-1;i>=0;i--){
    const f = fires[i];
    f.life -= dt;
    if(f.life <= 0){ fires.splice(i,1); continue; }
    f.x += f.vx * dt; f.y += f.vy * dt;
    f.vx *= 0.998; f.vy *= 0.998;
    const d = Math.hypot(player.x - f.x, player.y - f.y);
    if(d < f.r + Math.max(player.w, player.h)/2 - 6){
      if(invulTime <= 0 && !dying && state === 'playing'){
        setHP(hp - 0.5);
        const nx = (player.x - f.x) || 1;
        const ny = (player.y - f.y) || 0;
        const nl = Math.hypot(nx,ny) || 1;
        player.x += (nx/nl) * 28;
        player.y += (ny/nl) * 28;
        invulTime = Math.max(invulTime, 0.9); invulFlashTimer = 0;
        shakeTime = Math.max(shakeTime, 0.35); shakeIntensity = Math.max(shakeIntensity, 10);
        if(hp <= 0) startDeathAnimation(nx/nl, ny/nl);
      }
      fires.splice(i,1);
    }
  }
}

/* Burger (heal +1) & soda (speed boost) & clock (time) spawning */
function trySpawnBurgerAndSodaAndClock(dt){
  burgerTimer += dt;
  clockTimer += dt;
  // Burger (rare)
  if(!burger && burgerTimer > 10 + Math.random()*20){
    burgerTimer = 0;
    const prob = (difficulty==='easy')? 0.28 : (difficulty==='hard')? 0.7 : 0.44;
    if(Math.random() < prob) burger = { x: rnd(70, INTERNAL_W-70), y: rnd(70, INTERNAL_H-70), r: 16, emoji: 'ðŸ”', life: 12 + Math.random()*16, type:'burger' };
  }
  // Soda can (gives speed buff) - slightly more common
  if(!burger && Math.random() < 0.02 && Math.random() < (difficulty==='hard'?0.8:0.35)){
    // spawn soda separately as special pickup in pickups array
    pickups.push({ type:'soda', x: rnd(70, INTERNAL_W-70), y: rnd(70, INTERNAL_H-70), r:16, emoji:'ðŸ¥¤', life: 18 });
  }
  // Very rare clock
  if(!clockItem && clockTimer > 20 + Math.random()*40){
    clockTimer = 0;
    if(Math.random() < 0.06){ // very rare
      clockItem = { x: rnd(90, INTERNAL_W-90), y: rnd(90, INTERNAL_H-90), r: 16, emoji:'â°', life: 18 };
    }
  }
}
function updateSpecialPickups(dt){
  // burger
  if(burger){
    burger.life -= dt;
    if(burger.life <= 0) burger = null;
    else {
      const d = Math.hypot(player.x - burger.x, player.y - burger.y);
      if(d < burger.r + Math.max(player.w, player.h)/2 - 6){
        setHP(hp + 1);
        spawnParticlesAt(burger.x, burger.y);
        burger = null;
      }
    }
  }
  // clock
  if(clockItem){
    clockItem.life -= dt;
    if(clockItem.life <= 0) clockItem = null;
    else {
      const d = Math.hypot(player.x - clockItem.x, player.y - clockItem.y);
      if(d < clockItem.r + Math.max(player.w, player.h)/2 - 6){
        const add = 5 + Math.floor(Math.random()*6);
        gameTime += add;
        spawnParticlesAt(clockItem.x, clockItem.y);
        clockItem = null;
      }
    }
  }
  // soda handled as pickup in pickups list during pickup collision
}

/* Particles */
function spawnParticlesAt(x,y){
  for(let i=0;i<14;i++){
    const ang = Math.random()*Math.PI*2;
    const sp = Math.random()*160 + 40;
    particles.push({
      x,y,
      vx: Math.cos(ang)*sp,
      vy: Math.sin(ang)*sp,
      life: 0.35 + Math.random()*0.55,
      size: 6 + Math.random()*6,
      emoji: ['ðŸ’¥','âœ¨','ðŸ”¥'][Math.floor(Math.random()*3)]
    });
  }
}
function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.life -= dt;
    if(p.life <= 0) particles.splice(i,1);
    else { p.x += p.vx * dt; p.y += p.vy * dt; p.vx *= 0.98; p.vy *= 0.98; }
  }
}

/* Game update/render */
function update(dt){
  if(shakeTime > 0) shakeTime = Math.max(0, shakeTime - dt);
  if(invulTime > 0){ invulTime = Math.max(0, invulTime - dt); invulFlashTimer += dt; }
  if(sodaBuff > 0){ sodaBuff = Math.max(0, sodaBuff - dt); player.speed = player.baseSpeed * (sodaBuff>0?1.5:1); }
  updateParticles(dt); updateFires(dt); updateSpecialPickups(dt); updateMeteors(dt);

  if(!running || paused) return;

  if(dying){
    deathVy += GRAVITY * dt;
    player.y += deathVy * dt;
    player.x += player.vx * dt;
    if(player.y - player.h/2 > INTERNAL_H + 60) showGameOver('ðŸ’¥ You Died');
    return;
  }

  // special events
  tryStartMeteorShower(dt);
  trySpawnDragon(dt);
  updateDragon(dt);
  trySpawnBurgerAndSodaAndClock(dt);

  // timer
  gameTime -= dt;
  if(gameTime <= 0){ showGameOver('â³ Time Up'); return; }
  ui.time.textContent = Math.ceil(gameTime);

  // move player
  let dx=0, dy=0;
  if(keys['ArrowUp']||keys['w']) dy -= 1;
  if(keys['ArrowDown']||keys['s']) dy += 1;
  if(keys['ArrowLeft']||keys['a']) dx -= 1;
  if(keys['ArrowRight']||keys['d']) dx += 1;
  if(dx||dy){
    const len = Math.hypot(dx,dy) || 1;
    player.x += (dx/len) * player.speed * dt;
    player.y += (dy/len) * player.speed * dt;
  }
  player.x = clamp(player.x, player.w/2, INTERNAL_W - player.w/2);
  player.y = clamp(player.y, player.h/2, INTERNAL_H - player.h/2);

  // hazards move
  hazards.forEach(h=>{
    h.x += h.vx * dt; h.y += h.vy * dt;
    if(h.x < h.r || h.x > INTERNAL_W - h.r) h.vx *= -1;
    if(h.y < h.r || h.y > INTERNAL_H - h.r) h.vy *= -1;
  });

  // pickups collision (coins, gems, soda)
  for(let i=pickups.length-1;i>=0;i--){
    const p = pickups[i];
    const d = Math.hypot(player.x - p.x, player.y - p.y);
    if(d < p.r + Math.max(player.w,player.h)/2 - 4){
      if(p.type === 'coin'){
        setCoins(coins + (p.value || 1));
        setScore(score + (p.value || 1));
      } else if(p.type === 'gem'){
        setGems(gems + (p.value || 3));
        setScore(score + (p.value || 5));
      } else if(p.type === 'soda'){
        sodaBuff = 6; // 6 seconds of 1.5x speed
        player.speed = player.baseSpeed * 1.5;
      }
      pickups.splice(i,1);
      spawnParticlesAt(p.x, p.y);
      continue;
    }
  }

  // hazards collision (dynamite)
  for(let h of hazards){
    const d = Math.hypot(player.x - h.x, player.y - h.y);
    if(d < h.r + Math.max(player.w,player.h)/2 - 6){
      if(invulTime > 0) continue;
      if(h.emoji === 'ðŸ§¨'){
        setHP(hp - 1);
        const nx = (player.x - h.x) || 1;
        const ny = (player.y - h.y) || 0;
        const nl = Math.hypot(nx,ny);
        player.x += (nx/nl) * 36; player.y += (ny/nl) * 36;
        triggerExplosion(h);
        if(hp <= 0) { startDeathAnimation(nx/nl, ny/nl); return; }
      } else {
        setHP(hp - 1);
        const nx = (player.x - h.x) || 1;
        const ny = (player.y - h.y) || 0;
        const nl = Math.hypot(nx,ny);
        player.x += (nx/nl) * 36; player.y += (ny/nl) * 36;
        if(hp <= 0) { startDeathAnimation(nx/nl, ny/nl); return; }
      }
    }
  }

  // meteors on surface created hazards already handled in updateMeteors loop

  // spawn hazards ramp
  spawnTimer += dt;
  const ramp = (difficulty==='hard')?5.5:8;
  if(spawnTimer > ramp && hazards.length < 10){
    spawnTimer = 0;
    const v = (difficulty==='hard')? rnd(-160,160) : rnd(-120,120);
    hazards.push({ x:rnd(60,INTERNAL_W-60), y:rnd(60,INTERNAL_H-60), vx:v, vy:rnd(-120,120), r:16, emoji:'ðŸ§¨' });
  }
}

/* Explosion / death */
function triggerExplosion(h){
  shakeTime = Math.max(shakeTime, 0.55);
  shakeIntensity = Math.max(shakeIntensity, 8);
  invulTime = Math.max(invulTime, 1.0); invulFlashTimer = 0;
  h.x = clamp(h.x + (Math.random()-0.5)*140, 20, INTERNAL_W-20);
  h.y = clamp(h.y + (Math.random()-0.5)*140, 20, INTERNAL_H-20);
  spawnParticlesAt(h.x, h.y);
}
function startDeathAnimation(nx, ny){
  dying = true;
  deathVy = DEATH_JUMP;
  player.vx = (nx || 0) * 60;
  invulTime = 0;
  shakeTime = Math.max(shakeTime, 0.6);
  shakeIntensity = Math.max(shakeIntensity, 12);
  spawnParticlesAt(player.x, player.y);
}

/* Render */
function render(){
  ctx.save();
  if(shakeTime > 0){
    const shake = shakeIntensity * (shakeTime / 0.55);
    const sx = (Math.random()*2-1) * shake;
    const sy = (Math.random()*2-1) * shake;
    ctx.translate(sx, sy);
  }

  ctx.clearRect(0,0,INTERNAL_W,INTERNAL_H);
  ctx.fillStyle = '#07121b';
  ctx.fillRect(0,0,INTERNAL_W,INTERNAL_H);

  // grid
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1;
  const size = 48;
  for(let x=0;x<INTERNAL_W;x+=size){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,INTERNAL_H); ctx.stroke(); }
  for(let y=0;y<INTERNAL_H;y+=size){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(INTERNAL_W,y); ctx.stroke(); }

  // pickups (coins/gems/soda)
  pickups.forEach(p=> drawEmoji(p.emoji, p.x, p.y, p.r*2));
  // burger
  if(burger) drawEmoji(burger.emoji, burger.x, burger.y, 36);
  // clock
  if(clockItem) drawEmoji(clockItem.emoji, clockItem.x, clockItem.y, 36);

  // hazards
  hazards.forEach(h=> drawEmoji(h.emoji, h.x, h.y, h.r*2));

  // meteors shadow and meteor
  meteors.forEach(m=>{
    if(!m.landed){
      drawEmoji('â˜„ï¸', m.x, m.y, m.r*2.2);
    } else {
      // landed marker (already spawned hazard)
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.26)'; ctx.beginPath();
      ctx.ellipse(m.x, m.y+22, 40, 12, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  });

  // fires
  fires.forEach(f=> drawEmoji(f.emoji, f.x, f.y, f.r * 2.2));

  // particles
  particles.forEach(p=>{
    ctx.save();
    const a = Math.max(0, Math.min(1, p.life / 0.9));
    ctx.globalAlpha = a;
    drawEmoji(p.emoji, p.x, p.y, p.size);
    ctx.restore();
  });

  // dragon
  if(dragon){
    const em = 'ðŸ‰';
    const size = (dragon.state === 'spitting' || dragon.state === 'dropping') ? 84 : 72;
    drawEmoji(em, dragon.x, dragon.y, size);
  }

  // player
  if(dying){
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(0.06);
    ctx.font = `44px Segoe UI Emoji, Noto Color Emoji, Apple Color Emoji`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.globalAlpha = 0.95;
    ctx.fillText('ðŸ§‘â€ðŸš€', 0, 0);
    ctx.restore();
  } else {
    let drawP = true;
    if(invulTime > 0) drawP = Math.floor(invulFlashTimer / 0.12) % 2 === 0;
    if(drawP) drawEmoji('ðŸ§‘â€ðŸš€', player.x, player.y, 44);
  }

  ctx.restore();
}
function drawEmoji(emoji,x,y,size){
  ctx.save();
  ctx.translate(x,y);
  ctx.font = `${size}px Segoe UI Emoji, Noto Color Emoji, Apple Color Emoji`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(emoji, 0, 0);
  ctx.restore();
}

/* Game loop */
function loop(ts){
  const dt = Math.min(0.05, (ts - lastTime) / 1000);
  lastTime = ts;
  update(dt);
  render();
  if(running) requestAnimationFrame(loop);
}

/* Input */
window.addEventListener('keydown', e=>{
  if(e.repeat) return;
  keys[e.key] = true;
  if(state === 'menu' && (e.key === 'Enter' || e.key === ' ')) startGame();
  if(e.key === 'Escape'){
    if(state === 'playing') showPause();
    else if(state === 'paused') resumeGame();
  }
});
window.addEventListener('keyup', e=>{ keys[e.key] = false; });

// Click dash (short) -- fix teleport bug by using dash cooldown and max distance
canvas.addEventListener('click', e=>{
  if(state !== 'playing') return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  const now = performance.now() / 1000;
  if(now - lastDash < DASH_COOLDOWN) return;
  lastDash = now;
  const dx = mx - player.x, dy = my - player.y;
  const dist = Math.hypot(dx,dy);
  if(dist < 30) return;
  const dashDist = Math.min(DASH_DISTANCE, dist);
  const dirX = dx / dist, dirY = dy / dist;
  player.x += dirX * dashDist; player.y += dirY * dashDist;
  shakeTime = Math.max(shakeTime, 0.12); shakeIntensity = Math.max(shakeIntensity, 5);
});

/* Buttons & difficulty */
ui.playBtn.addEventListener('click', ()=> startGame());
ui.easyBtn.addEventListener('click', ()=> { difficulty='easy'; markDifficultyButton(); ui.easyBtn.classList.add('active'); });
ui.hardBtn.addEventListener('click', ()=> { difficulty='hard'; markDifficultyButton(); ui.hardBtn.classList.add('active'); });
ui.restartBtn.addEventListener('click', ()=> startGame());
ui.resumeBtn.addEventListener('click', ()=> resumeGame());
ui.menuHomeBtn.addEventListener('click', ()=> showMenu());
ui.menuBackBtn.addEventListener('click', ()=> showMenu());

/* Start menu */
markDifficultyButton();
showMenu();

/* Helper: spawn diamond/coins and rare soda/gem additions during runtime occasionally */
function pickOneAtRandom(){
  // spawn coins mostly, sometimes gem, sometimes soda
  if(Math.random() < 0.12){
    pickups.push({ type:'gem', x: rnd(60,INTERNAL_W-60), y: rnd(60,INTERNAL_H-60), r:14, emoji:'ðŸ’Ž', value:5 });
  } else if(Math.random() < 0.08){
    pickups.push({ type:'soda', x: rnd(60,INTERNAL_W-60), y: rnd(60,INTERNAL_H-60), r:14, emoji:'ðŸ¥¤' });
  } else {
    pickups.push({ type:'coin', x: rnd(60,INTERNAL_W-60), y: rnd(60,INTERNAL_H-60), r:12, emoji:'ðŸª™', value:1 });
  }
}

/* Periodic spawning helper used in init and later */
function spawnPeriodicPickups(dt){
  spawnTimer += dt;
  if(spawnTimer > 6){
    spawnTimer = 0;
    pickOneAtRandom();
  }
}

/* Wire periodic spawns into update loop by extending update */
const originalUpdate = update;
update = function(dt){
  // run base logic (defined earlier) by copying contents into this new wrapper, to integrate periodic spawns
  // We'll inline needed parts because originalUpdate refers to itself earlier. For clarity we call internalUpdate here.
  // internalUpdate below is the same as previous update body but we add spawnPeriodicPickups and tryStartMeteorShower calls are present already.
  // To avoid duplicating too much, call the previously defined update logic by using a small shim:
  internalUpdate(dt);
};

/* To avoid duplicating the earlier large update, define internalUpdate as the previous function's body.
   (Implementation note: we've already declared update earlier; to keep file concise, we'll directly replace internalUpdate with the real logic.)
*/

// Re-declare internalUpdate with the full update logic used earlier
function internalUpdate(dt){
  if(shakeTime > 0) shakeTime = Math.max(0, shakeTime - dt);
  if(invulTime > 0){ invulTime = Math.max(0, invulTime - dt); invulFlashTimer += dt; }
  if(sodaBuff > 0){ sodaBuff = Math.max(0, sodaBuff - dt); player.speed = player.baseSpeed * (sodaBuff>0?1.5:1); }
  updateParticles(dt); updateFires(dt); updateSpecialPickups(dt); updateMeteors(dt);

  if(!running || paused) return;

  if(dying){
    deathVy += GRAVITY * dt;
    player.y += deathVy * dt;
    player.x += player.vx * dt;
    if(player.y - player.h/2 > INTERNAL_H + 60) showGameOver('ðŸ’¥ You Died');
    return;
  }

  // special events
  tryStartMeteorShower(dt);
  trySpawnDragon(dt);
  updateDragon(dt);
  trySpawnBurgerAndSodaAndClock(dt);

  // spawn periodic pickups
  spawnPeriodicPickups(dt);

  // game timer
  gameTime -= dt;
  if(gameTime <= 0){ showGameOver('â³ Time Up'); return; }
  ui.time.textContent = Math.ceil(gameTime);

  // move player
  let dx=0, dy=0;
  if(keys['ArrowUp']||keys['w']) dy -= 1;
  if(keys['ArrowDown']||keys['s']) dy += 1;
  if(keys['ArrowLeft']||keys['a']) dx -= 1;
  if(keys['ArrowRight']||keys['d']) dx += 1;
  if(dx||dy){
    const len = Math.hypot(dx,dy) || 1;
    player.x += (dx/len) * player.speed * dt;
    player.y += (dy/len) * player.speed * dt;
  }
  player.x = clamp(player.x, player.w/2, INTERNAL_W - player.w/2);
  player.y = clamp(player.y, player.h/2, INTERNAL_H - player.h/2);

  // hazards move
  hazards.forEach(h=>{
    h.x += h.vx * dt; h.y += h.vy * dt;
    if(h.x < h.r || h.x > INTERNAL_W - h.r) h.vx *= -1;
    if(h.y < h.r || h.y > INTERNAL_H - h.r) h.vy *= -1;
  });

  // pickups collision (coins, gems, soda)
  for(let i=pickups.length-1;i>=0;i--){
    const p = pickups[i];
    const d = Math.hypot(player.x - p.x, player.y - p.y);
    if(d < p.r + Math.max(player.w,player.h)/2 - 4){
      if(p.type === 'coin'){
        setCoins(coins + (p.value || 1)); setScore(score + (p.value || 1));
      } else if(p.type === 'gem'){
        setGems(gems + (p.value || 3)); setScore(score + (p.value || 5));
      } else if(p.type === 'soda'){
        sodaBuff = 6; player.speed = player.baseSpeed * 1.5;
      }
      pickups.splice(i,1); spawnParticlesAt(p.x, p.y); continue;
    }
  }

  // hazards collision
  for(let h of hazards){
    const d = Math.hypot(player.x - h.x, player.y - h.y);
    if(d < h.r + Math.max(player.w,player.h)/2 - 6){
      if(invulTime > 0) continue;
      if(h.emoji === 'ðŸ§¨'){
        setHP(hp - 1);
        const nx = (player.x - h.x) || 1; const ny = (player.y - h.y) || 0;
        const nl = Math.hypot(nx,ny);
        player.x += (nx/nl) * 36; player.y += (ny/nl) * 36;
        triggerExplosion(h);
        if(hp <= 0) { startDeathAnimation(nx/nl, ny/nl); return; }
      } else {
        setHP(hp - 1);
        const nx = (player.x - h.x) || 1; const ny = (player.y - h.y) || 0;
        const nl = Math.hypot(nx,ny);
        player.x += (nx/nl) * 36; player.y += (ny/nl) * 36;
        if(hp <= 0) { startDeathAnimation(nx/nl, ny/nl); return; }
      }
    }
  }

  // spawn hazards ramp
  spawnTimer += dt;
  const ramp = (difficulty==='hard')?5.5:8;
  if(spawnTimer > ramp && hazards.length < 10){
    spawnTimer = 0;
    const v = (difficulty==='hard')? rnd(-160,160) : rnd(-120,120);
    hazards.push({ x:rnd(60,INTERNAL_W-60), y:rnd(60,INTERNAL_H-60), vx:v, vy:rnd(-120,120), r:16, emoji:'ðŸ§¨' });
  }
}

/* Start the loop when ready */
lastTime = performance.now();
requestAnimationFrame(loop);
