// Emoji Top-down with dragon burst-spit behavior and rare burger heal spawn.
// Dragon now does a rapid burst (many small fires in quick succession) then leaves.
// Rare burger spawns occasionally to heal +1 HP.

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

const ui = {
  score: document.getElementById('score'),
  gems: document.getElementById('gems'),
  hp: document.getElementById('hp'),
  time: document.getElementById('time'),
  overlay: document.getElementById('overlay'),
  menu: document.getElementById('menu'),
  pause: document.getElementById('pause'),
  gameover: document.getElementById('gameover'),
  msg: document.getElementById('msg'),
  finalStats: document.getElementById('final-stats'),
  playBtn: document.getElementById('play'),
  easyBtn: document.getElementById('easy'),
  hardBtn: document.getElementById('hard'),
  restartBtn: document.getElementById('restart'),
  resumeBtn: document.getElementById('resume'),
  menuHomeBtn: document.getElementById('menu-home'),
  menuBackBtn: document.getElementById('menu-back')
};

let keys = {};
let lastTime = 0;
let spawnTimer = 0;
let dragonTimer = 0;
let burgerTimer = 0;
let gameTime = 60;
let score = 0, gems = 0, hp = 3.0;
let running = false;
let paused = false;
let difficulty = 'normal'; // easy, normal, hard
let state = 'menu'; // menu, playing, paused, gameover

let player, hazards = [], pickups = [];

// visual/effect state
let shakeTime = 0, shakeIntensity = 0;
let invulTime = 0, invulFlashTimer = 0;
let particles = [];

// death state
let dying = false;
let deathVy = 0;
const GRAVITY = 900;
const DEATH_JUMP = -420;

// Dragon, fires, burger
let dragon = null; // dragon object or null
let fires = [];    // active spit fires
let burger = null; // rare heal item {x,y,r,life}

// Utilities
function rnd(min, max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function setHP(v){ hp = Math.max(0, Math.min(3, +(v).toFixed(2))); ui.hp.textContent = hp.toFixed(1); }

// UI / state control
function showMenu(){
  state = 'menu';
  running = false;
  paused = false;
  ui.menu.classList.remove('hidden');
  ui.pause.classList.add('hidden');
  ui.gameover.classList.add('hidden');
  ui.overlay.classList.add('overlay-active');
}
function startGame(){
  state = 'playing';
  running = true;
  paused = false;
  ui.menu.classList.add('hidden');
  ui.pause.classList.add('hidden');
  ui.gameover.classList.add('hidden');
  ui.overlay.classList.remove('overlay-active');
  initGame();
  lastTime = performance.now();
  requestAnimationFrame(loop);
}
function showPause(){
  if(state !== 'playing') return;
  state = 'paused';
  paused = true;
  ui.pause.classList.remove('hidden');
  ui.overlay.classList.add('overlay-active');
}
function resumeGame(){
  if(state !== 'paused') return;
  state = 'playing';
  paused = false;
  ui.pause.classList.add('hidden');
  ui.overlay.classList.remove('overlay-active');
  lastTime = performance.now();
  requestAnimationFrame(loop);
}
function showGameOver(text){
  state = 'gameover';
  running = false;
  paused = false;
  dying = false;
  ui.menu.classList.add('hidden');
  ui.pause.classList.add('hidden');
  ui.gameover.classList.remove('hidden');
  ui.msg.textContent = text;
  ui.finalStats.textContent = `Score ${score} â€¢ Gems ${gems}`;
  ui.overlay.classList.add('overlay-active');
}

// Initialization
function initGame(){
  score = 0; gems = 0; setHP(3.0);
  gameTime = (difficulty === 'easy') ? 90 : (difficulty === 'hard') ? 45 : 60;
  hazards = []; pickups = [];
  player = {
    x: W/2,
    y: H/2,
    w: 28,
    h: 28,
    speed: (difficulty==='hard'?200:160),
    emoji: 'ðŸ™‚',
    vx: 0, vy: 0
  };
  ui.score.textContent = score;
  ui.gems.textContent = gems;
  ui.time.textContent = Math.ceil(gameTime);
  lastTime = performance.now();
  spawnPickup();
  spawnHazard();
  spawnTimer = 0;
  dragonTimer = 0;
  burgerTimer = 0;
  dragon = null;
  fires = [];
  burger = null;
  particles = [];
  shakeTime = 0; shakeIntensity = 0;
  invulTime = 0; invulFlashTimer = 0;
  dying = false; deathVy = 0;
}

function spawnPickup(){
  for(let i=0;i<4;i++){
    pickups.push({ x: rnd(20,W-20), y: rnd(20,H-20), r:12, emoji:'ðŸ’Ž' });
  }
}
function spawnHazard(){
  const count = (difficulty==='easy')?2:3;
  for(let i=0;i<count;i++){
    const speed = (difficulty==='hard')? rnd(-140,140) : rnd(-80,80);
    hazards.push({ x:rnd(40,W-40), y:rnd(40,H-40), vx: speed, vy: rnd(-80,80), r:16, emoji:'ðŸ§¨' });
  }
}

/* ---- Dragon behavior (burst spit then flee) ----
 States:
  - null: absent
  - approaching: flying in from side/top toward targetX (shadow drawn)
  - dropping: descending to surfaceY
  - spitting: performs a rapid burst of many small fires over a short window
  - leaving: lifts off and flees
 Dragon spawns more frequently in hard mode.
*/

// spawn logic
function trySpawnDragon(dt){
  if(difficulty !== 'hard') return;
  dragonTimer += dt;
  // attempt spawn more often in hard mode
  if(dragonTimer > 5 + Math.random()*4){
    dragonTimer = 0;
    if(!dragon && Math.random() < 0.65){
      const dropX = rnd(80, W-80);
      const startX = Math.random() < 0.5 ? -120 : W + 120;
      dragon = {
        x: startX,
        y: -140,
        targetX: dropX,
        surfaceY: rnd(90, 170),
        state: 'approaching',
        speed: 140 + Math.random()*80,
        spitBurstCount: 0,
        spitBurstTotal: 6 + Math.floor(Math.random()*8), // many quick shots per burst
        spitBurstInterval: 0.06 + Math.random()*0.06,
        spitBurstTimer: 0,
        leaveDelay: 0.3
      };
    }
  }
}

function updateDragon(dt){
  if(!dragon) return;
  if(dragon.state === 'approaching'){
    // interpolate toward target x and descend a bit
    const dx = dragon.targetX - dragon.x;
    const step = Math.sign(dx) * Math.min(Math.abs(dx), dragon.speed * dt);
    dragon.x += step;
    dragon.y += 50 * dt;
    if(Math.abs(dx) < 8 && dragon.y >= -10){
      dragon.state = 'dropping';
    }
  } else if(dragon.state === 'dropping'){
    dragon.y += 260 * dt;
    if(dragon.y >= dragon.surfaceY){
      dragon.y = dragon.surfaceY;
      dragon.state = 'spitting';
      dragon.spitBurstCount = 0;
      dragon.spitBurstTimer = 0.05; // short delay before burst
    }
  } else if(dragon.state === 'spitting'){
    dragon.spitBurstTimer -= dt;
    // perform rapid-fire burst: fire many small fire projectiles quickly
    while(dragon.spitBurstTimer <= 0 && dragon.spitBurstCount < dragon.spitBurstTotal){
      spitBurstSmallFire();
      dragon.spitBurstCount++;
      dragon.spitBurstTimer += dragon.spitBurstInterval;
    }
    if(dragon.spitBurstCount >= dragon.spitBurstTotal){
      // after finishing burst, wait small delay then leave
      dragon.leaveDelay -= dt;
      if(dragon.leaveDelay <= 0){
        dragon.state = 'leaving';
        dragon.vx = (Math.random() < 0.5 ? -1 : 1) * (dragon.speed + 80);
        dragon.vy = -260;
      }
    }
  } else if(dragon.state === 'leaving'){
    dragon.x += dragon.vx * dt;
    dragon.y += dragon.vy * dt;
    dragon.vy += -420 * dt; // accelerate upward
    if(dragon.y < -160 || dragon.x < -260 || dragon.x > W + 260){
      dragon = null;
    }
  }
}

// burst spit: small fast fires in slightly different directions toward player location with spread
function spitBurstSmallFire(){
  if(!dragon) return;
  const fx = dragon.x;
  const fy = dragon.y + 22;
  // aim at player with spread
  const aimX = player.x + rnd(-60,60);
  const aimY = player.y + rnd(-30,30);
  const dirX = aimX - fx;
  const dirY = aimY - fy;
  const len = Math.hypot(dirX, dirY) || 1;
  const speed = 360 + Math.random()*120;
  fires.push({
    x: fx,
    y: fy,
    vx: (dirX/len) * speed + rnd(-30,30),
    vy: (dirY/len) * speed + rnd(-20,20),
    r: 8,
    life: 2.5,
    emoji: 'ðŸ”¥'
  });
}

/* Fires update & collision (each fire disappears on hit and deals -0.5 HP) */
function updateFires(dt){
  for(let i=fires.length-1;i>=0;i--){
    const f = fires[i];
    f.life -= dt;
    if(f.life <= 0){
      fires.splice(i,1);
      continue;
    }
    f.x += f.vx * dt;
    f.y += f.vy * dt;
    f.vx *= 0.998;
    f.vy *= 0.998;
    // collision with player
    const d = Math.hypot(player.x - f.x, player.y - f.y);
    if(d < f.r + Math.max(player.w, player.h)/2 - 6){
      if(invulTime <= 0 && !dying && state === 'playing'){
        setHP(hp - 0.5);
        const nx = (player.x - f.x) || 1;
        const ny = (player.y - f.y) || 0;
        const nl = Math.hypot(nx,ny) || 1;
        player.x += (nx/nl) * 28;
        player.y += (ny/nl) * 28;
        invulTime = Math.max(invulTime, 0.9);
        invulFlashTimer = 0;
        shakeTime = Math.max(shakeTime, 0.35);
        shakeIntensity = Math.max(shakeIntensity, 8);
        if(hp <= 0){
          startDeathAnimation(nx/nl, ny/nl);
        }
      }
      // remove fire regardless
      fires.splice(i,1);
    }
  }
}

/* Burger spawn - rare heal +1 HP */
function trySpawnBurger(dt){
  burgerTimer += dt;
  if(!burger && burgerTimer > 10 + Math.random()*20){
    // rare: lower chance on easy, higher on hard
    const prob = (difficulty==='easy')? 0.25 : (difficulty==='hard')? 0.6 : 0.4;
    burgerTimer = 0;
    if(Math.random() < prob){
      burger = { x: rnd(40, W-40), y: rnd(40, H-40), r: 14, emoji: 'ðŸ”', life: 12 + Math.random()*12 };
    }
  }
}
function updateBurger(dt){
  if(!burger) return;
  burger.life -= dt;
  if(burger.life <= 0){
    burger = null;
    return;
  }
  // collision with player => heal +1 (cap to 3)
  const d = Math.hypot(player.x - burger.x, player.y - burger.y);
  if(d < burger.r + Math.max(player.w, player.h)/2 - 6){
    setHP(hp + 1);
    // small pop particles
    spawnParticlesAt(burger.x, burger.y);
    burger = null;
  }
}

/* Particles */
function spawnParticlesAt(x,y){
  for(let i=0;i<14;i++){
    const ang = Math.random()*Math.PI*2;
    const sp = Math.random()*160 + 40;
    particles.push({
      x, y,
      vx: Math.cos(ang)*sp,
      vy: Math.sin(ang)*sp,
      life: 0.35 + Math.random()*0.55,
      size: 6 + Math.random()*6,
      emoji: ['ðŸ’¥','âœ¨','ðŸ”¥'][Math.floor(Math.random()*3)]
    });
  }
}
function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.life -= dt;
    if(p.life <= 0) particles.splice(i,1);
    else {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.98;
      p.vy *= 0.98;
    }
  }
}

/* Core update/render */
function update(dt){
  if(shakeTime > 0) shakeTime = Math.max(0, shakeTime - dt);
  if(invulTime > 0) {
    invulTime = Math.max(0, invulTime - dt);
    invulFlashTimer += dt;
  }
  updateParticles(dt);
  updateFires(dt);
  updateBurger(dt);

  if(!running || paused) return;

  if(dying){
    deathVy += GRAVITY * dt;
    player.y += deathVy * dt;
    player.x += player.vx * dt;
    if(player.y - player.h/2 > H + 60){
      showGameOver('ðŸ’¥ You Died');
    }
    return;
  }

  // dragon logic
  trySpawnDragon(dt);
  updateDragon(dt);

  // burger spawn logic
  trySpawnBurger(dt);

  // normal game timer
  gameTime -= dt;
  if(gameTime <= 0){ showGameOver('â³ Time Up'); return; }
  ui.time.textContent = Math.ceil(gameTime);

  // player movement
  let dx=0, dy=0;
  if(keys['ArrowUp']||keys['w']) dy -= 1;
  if(keys['ArrowDown']||keys['s']) dy += 1;
  if(keys['ArrowLeft']||keys['a']) dx -= 1;
  if(keys['ArrowRight']||keys['d']) dx += 1;
  if(dx||dy){
    const len = Math.hypot(dx,dy) || 1;
    player.x += (dx/len) * player.speed * dt;
    player.y += (dy/len) * player.speed * dt;
  }
  player.x = clamp(player.x, player.w/2, W - player.w/2);
  player.y = clamp(player.y, player.h/2, H - player.h/2);

  // hazards move
  hazards.forEach(h=>{
    h.x += h.vx * dt;
    h.y += h.vy * dt;
    if(h.x < h.r || h.x > W - h.r) h.vx *= -1;
    if(h.y < h.r || h.y > H - h.r) h.vy *= -1;
  });

  // pickups collision
  for(let i=pickups.length-1;i>=0;i--){
    let p = pickups[i];
    let d = Math.hypot(player.x - p.x, player.y - p.y);
    if(d < p.r + Math.max(player.w,player.h)/2 - 4){
      pickups.splice(i,1);
      score += 10; gems += 1;
      ui.score.textContent = score;
      ui.gems.textContent = gems;
      setTimeout(()=> pickOneAtRandom(), 400 + Math.random()*800);
    }
  }

  // hazards collision (dynamite explosion)
  for(let h of hazards){
    let d = Math.hypot(player.x - h.x, player.y - h.y);
    if(d < h.r + Math.max(player.w,player.h)/2 - 6){
      if(invulTime > 0) continue;
      if(h.emoji === 'ðŸ§¨'){
        setHP(hp - 1);
        const nx = (player.x - h.x) || 1;
        const ny = (player.y - h.y) || 0;
        const nl = Math.hypot(nx,ny);
        player.x += (nx/nl) * 36;
        player.y += (ny/nl) * 36;
        triggerExplosion(h);
        if(hp <= 0){
          startDeathAnimation(nx/nl, ny/nl);
          return;
        }
      } else {
        setHP(hp - 1);
        const nx = (player.x - h.x) || 1;
        const ny = (player.y - h.y) || 0;
        const nl = Math.hypot(nx,ny);
        player.x += (nx/nl) * 36;
        player.y += (ny/nl) * 36;
        if(hp <= 0){
          startDeathAnimation(nx/nl, ny/nl);
          return;
        }
      }
    }
  }

  // difficulty ramp hazards spawn
  spawnTimer += dt;
  const ramp = (difficulty==='hard')?5.5:8;
  if(spawnTimer > ramp && hazards.length < 8){
    spawnTimer = 0;
    const v = (difficulty==='hard')? rnd(-160,160) : rnd(-120,120);
    hazards.push({ x:rnd(40,W-40), y:rnd(40,H-40), vx:v, vy:rnd(-120,120), r:16, emoji:'ðŸ§¨' });
  }
}

function triggerExplosion(h){
  shakeTime = Math.max(shakeTime, 0.55);
  shakeIntensity = Math.max(shakeIntensity, 8);
  invulTime = Math.max(invulTime, 1.0);
  invulFlashTimer = 0;
  h.x = clamp(h.x + (Math.random()-0.5)*140, 20, W-20);
  h.y = clamp(h.y + (Math.random()-0.5)*140, 20, H-20);
  spawnParticlesAt(h.x, h.y);
}

function startDeathAnimation(nx, ny){
  dying = true;
  deathVy = DEATH_JUMP;
  player.vx = (nx || 0) * 60;
  invulTime = 0;
  shakeTime = Math.max(shakeTime, 0.6);
  shakeIntensity = Math.max(shakeIntensity, 12);
  spawnParticlesAt(player.x, player.y);
}

function pickOneAtRandom(){
  pickups.push({ x:rnd(20,W-20), y:rnd(20,H-20), r:12, emoji:'ðŸ’Ž' });
}

/* Rendering: draw dragon shadow, dragon, fires, burger, particles, player, pickups, hazards */
function render(){
  ctx.save();
  if(shakeTime > 0){
    const shake = shakeIntensity * (shakeTime / 0.55);
    const sx = (Math.random()*2-1) * shake;
    const sy = (Math.random()*2-1) * shake;
    ctx.translate(sx, sy);
  }

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#07121b';
  ctx.fillRect(0,0,W,H);

  // grid
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1;
  const size = 32;
  for(let x=0;x<W;x+=size){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<H;y+=size){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

  // pickups & hazards
  pickups.forEach(p=> drawEmoji(p.emoji, p.x, p.y, p.r*2));
  hazards.forEach(h=> drawEmoji(h.emoji, h.x, h.y, h.r*2));

  // dragon shadow
  if(dragon && (dragon.state === 'approaching' || dragon.state === 'dropping' || dragon.state === 'spitting')){
    const sx = dragon.targetX;
    const sy = dragon.surfaceY + 22;
    ctx.save();
    ctx.translate(sx, sy);
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    const w = 64;
    const h = 18;
    ctx.beginPath();
    ctx.ellipse(0,0, w/2, h/2, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // fires
  fires.forEach(f=>{
    drawEmoji(f.emoji, f.x, f.y, f.r*1.6);
  });

  // burger (rare heal)
  if(burger){
    // pulse size with life
    const psize = 28 + Math.sin(Date.now()/160)*2;
    drawEmoji(burger.emoji, burger.x, burger.y, psize);
  }

  // particles
  particles.forEach(p=>{
    ctx.save();
    const a = Math.max(0, Math.min(1, p.life / 0.9));
    ctx.globalAlpha = a;
    drawEmoji(p.emoji, p.x, p.y, p.size);
    ctx.restore();
  });

  // dragon sprite
  if(dragon){
    const em = 'ðŸ‰';
    const size = (dragon.state === 'spitting' || dragon.state === 'dropping') ? 64 : 56;
    drawEmoji(em, dragon.x, dragon.y, size);
  }

  // player draw (flash when invul)
  if(dying){
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(0.06);
    ctx.font = `34px Segoe UI Emoji, Noto Color Emoji, Apple Color Emoji`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.globalAlpha = 0.95;
    ctx.fillText('ðŸ§‘â€ðŸš€', 0, 0);
    ctx.restore();
  } else {
    let drawPlayer = true;
    if(invulTime > 0) drawPlayer = Math.floor(invulFlashTimer / 0.12) % 2 === 0;
    if(drawPlayer) drawEmoji('ðŸ§‘â€ðŸš€', player.x, player.y, 34);
  }

  ctx.restore();
}

function drawEmoji(emoji, x, y, size){
  ctx.save();
  ctx.translate(x,y);
  ctx.font = `${size}px Segoe UI Emoji, Noto Color Emoji, Apple Color Emoji`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(emoji, 0, 0);
  ctx.restore();
}

function loop(ts){
  const dt = Math.min(0.05, (ts - lastTime) / 1000);
  lastTime = ts;
  update(dt);
  render();
  if(running) requestAnimationFrame(loop);
}

/* Input handling */
window.addEventListener('keydown', e=>{
  if(e.repeat) return;
  keys[e.key] = true;

  if(state === 'menu' && (e.key === 'Enter' || e.key === ' ')) startGame();

  // ESC toggles pause
  if(e.key === 'Escape'){
    if(state === 'playing') showPause();
    else if(state === 'paused') resumeGame();
  }
});
window.addEventListener('keyup', e=>{ keys[e.key] = false; });

canvas.addEventListener('click', e=>{
  if(state !== 'playing') return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  const dx = mx - player.x, dy = my - player.y;
  const l = Math.hypot(dx,dy) || 1;
  player.x += (dx/l) * 90;
  player.y += (dy/l) * 90;
});

/* Buttons */
ui.playBtn.addEventListener('click', ()=> startGame());
ui.easyBtn.addEventListener('click', ()=> { difficulty='easy'; ui.easyBtn.style.background='var(--accent)'; ui.hardBtn.style.background='rgba(255,255,255,0.04)'; });
ui.hardBtn.addEventListener('click', ()=> { difficulty='hard'; ui.hardBtn.style.background='var(--accent)'; ui.easyBtn.style.background='rgba(255,255,255,0.04)'; });
ui.restartBtn.addEventListener('click', ()=> startGame());
ui.resumeBtn.addEventListener('click', ()=> resumeGame());
ui.menuHomeBtn.addEventListener('click', ()=> showMenu());
ui.menuBackBtn.addEventListener('click', ()=> showMenu());

/* Start on menu */
showMenu();